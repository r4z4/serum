
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Benchmarking in Elixir Using Benchee (& Erlang) - r4z4 Site</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/home_animation.css">
    <link rel="stylesheet" href="/assets/css/markdown.css">
  </head>
  <body>
    
<div id="navbar_div">
  <ul id="navbar">
    <li><a href="/index.html">Home</a></li>
    <li><a href="/posts">Posts</a></li>
  </ul>
</div>

    <h1 class="base-header"><a href="/">Various Writings and Observations</a></h1>
    <section class="md-body"><h1 id="benchmarking-in-elixir-using-benchee-(&amp;-erlang)">Benchmarking in Elixir Using Benchee (&amp; Erlang)</h1><p>Posted on Wednesday, 16 Aug 2023 by r4z4</p><p>Tags:</p><ul><li><a href="/tags/benchmark">benchmark</a></li><li><a href="/tags/elixir">elixir</a></li><li><a href="/tags/erlang">erlang</a></li></ul><p>I never really thought that I‚Äôd get to the point of wanting or needing to profile my operations, but after you spend a lot of time doing the same thing over and over, it is natural to want to try and find the best way to do it. From a pure efficiency perspective, it makes sense to save x nanoseconds each time we operate if we know we will be operating many thousands of times per day üòä.</p><p>Plus, it is just the responsible thing to do. I cannot rebel against growing up in every facet of my life. </p><hr class="thin"/><p>This first really came up when realizing the extent of my Enum and List operations. I always knew ‚ÄúList bad for access‚Äù but its just so natural and hard to shake ‚Ä¶ things just go in lists. So, let‚Äôs put some hard numbers on it to finally, once and for all, convince myself to go the other way. Tuple vs. List. One comparison that I found along the way was the think of a tuple as a DB row. Typically each of the elements relate to a common source, and you can see why you would not want to enumerate over that.</p><hr class="thin"/><p>It is worth noting we get suspicious results when just utilizing the built-in Erlang tools. To be fair, though, they do provide a warning for us in the <a href="https://www.erlang.org/doc/efficiency_guide/profiling.html#benchmarking">OTP Efficiency Guide</a>.</p><p>&gt;timer:tc/3 measures wall-clock time. The advantage with wall-clock time is that I/O, swapping, and other activities in the operating system kernel are included in the measurements. The disadvantage is that the measurements vary a lot. Usually it is best to run the benchmark several times and note the shortest time, which is to be the minimum time that is possible to achieve under the best of circumstances ‚Ä¶ Therefore, measuring CPU time is misleading if any I/O (file or socket) is involved.</p><hr class="thin"/><p>Here is the signature for the <code class="inline">tc/2</code> function (the additional argument in the <code class="inline">tc/3</code> function is the TimeUnit, which will be defaulted to microseconds when we use the <code class="inline">tc/2</code> function)</p><p><code class="inline">tc(Fun, Arguments) -&gt; {Time, Value}</code> which means we will be using the <code class="inline">tc/2</code> function.</p><p>When we run this function just within our application, though, the results are not so great.</p><pre><code class="erlang">{uSecs, :ok} = :timer.tc(&amp;func/arity, [func-args])</code></pre><pre><code class="shell-session">List Time: 0
Tup Time: 1</code></pre><p>Of course this is also likely a factor of just having a much smaller function as well, as we will see here soon when we run the Erlang timer on the much more expensive operation. There are also other modules w/in Erlang you can use too, like <code class="inline">erlang::statistics</code>.
With that said, we‚Äôll turn to <a href="https://github.com/bencheeorg/benchee">Benchee</a>. I did use another Library called Benchfella to begin but Benchee is actively supported &amp; maintained and seems to be the one that most Elixir
developers will reach for.  </p><p>Gotta do the usual to add it to the project. Unlike Benchfella though we do not need to directly add it as a child process in our main application function.</p><pre><code class="elixir">defp deps do
  [{:benchee, &quot;~&gt; 1.0&quot;, only: :dev}]
end</code></pre><p>Then do ‚Ä¶</p><pre><code class="elixir">$ mix deps.get
...
$ mix compile</code></pre><p>Now just set up a file and run it. You can either create a module as you normally might for a custom module you want to implement, or we can just create a script and then run it with a <code class="inline">mix run</code> command. We‚Äôll use the second option here just because it will be much simpler to execute and go in and change to our needs. If I needed to build upon them as the application evolved, a formal module might be the preferred approach. Create the file <code class="inline">bencnmark.exs</code>.</p><pre><code class="elixir">list = Enum.to_list(1..10_000)
tuple = List.to_tuple(list)

Benchee.run(
  %{
    &quot;EnumAt&quot; =&gt; fn -&gt; Enum.at(list, 2222) end,
    &quot;KernelElem&quot; =&gt; fn -&gt; Kernel.elem(tuple, 2222) end
  },
  time: 10,
  memory_time: 2
)</code></pre><pre><code class="shell-session">Benchmarking EnumAt ...
Benchmarking KernelElem ...
[notice]     :alarm_handler: {:set, {:system_memory_high_watermark, []}}
[notice]     :alarm_handler: {:set, {:process_memory_high_watermark, #PID&lt;0.101.0&gt;}}

Name                 ips        average  deviation         median         99th %
KernelElem       25.49 M      0.0392 Œºs ¬±21713.36%           0 Œºs       0.100 Œºs
EnumAt           0.143 M        7.01 Œºs  ¬±1104.59%        5.90 Œºs       21.20 Œºs

Comparison: 
KernelElem       25.49 M
EnumAt           0.143 M - 178.67x slower +6.97 Œºs

Memory usage statistics:

Name          Memory usage
KernelElem             0 B
EnumAt                16 B - ‚àû x memory usage +16 B

**All measurements for memory usage were the same**</code></pre><p>Using the libraries helps us isolate the functions and eliminate a lot of the noise that can contribute to faulty or suspicious results.</p><pre><code class="shell-session">List Time: 88
Tup Time: 0</code></pre></section>
  </body>
</html>
<script>
const ws_url = "ws://" + location.host + "/serum_live_reloader";
var ws;

connect();

function connect() {
  ws = new WebSocket(ws_url);
  ws.onmessage = onMessage;
  ws.onclose = onClose;
}

function onMessage(e) {
  if (e.data === "reload") {
    location.reload();
  }
}

function onClose(e) {
  console.warn("WebSocket disconnected from server. Reconnecting in 10 seconds.");
  setTimeout(connect, 10000)
}
</script>
